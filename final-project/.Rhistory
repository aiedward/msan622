stop("Number of eigenvalues for plot is larger than the number of data points")
}else{
#Get W, D and L
W<-similarity_mat(x,sigma=sigma)
D<-diag(apply(W,1,sum))
L<-D-W
#Calculate eigenvalues/vectors
eigenL<-eigen(L)
evalues<-eigenL$values
evectors<-eigenL$vectors
#Order eigenvalues from the smallest to the largest
idx<-order(evalues)
evalues<-evalues[idx][1:plot_eigen]
evectors<-evectors[,idx[1:plot_eigen]]
#Create Plot
m<-ceiling((1+plot_eigen)/3)
par(mfrow=c(m,3))
plot(evalues[order(evalues)],main="Eigenvalues",ylab="eigenvalues")
for(i in 1:plot_eigen){
make_title<-paste(paste(i,"th",sep=""),"Eigenvector")
plot(evectors[,i],type="l",main=make_title,ylab="values")
}
km<-kmeans(evectors,centers=k)
cluster<-km$cluster
return(cluster)
}
spectrulClustering<-function(x,sigma,plot_eigen,k){
#x is data
#sigma is sigma used in Gaussian function
#num_plot is how many eigenvalues are plotted from the smallest?
#k is the kmeans clustering's parameter
n<-dim(x)[1]
if(plot_eigen>n){
stop("Number of eigenvalues for plot is larger than the number of data points")
}else{
#Get W, D and L
W<-similarity_mat(x,sigma=sigma)
D<-diag(apply(W,1,sum))
L<-D-W
#Calculate eigenvalues/vectors
eigenL<-eigen(L)
evalues<-eigenL$values
evectors<-eigenL$vectors
#Order eigenvalues from the smallest to the largest
idx<-order(evalues)
evalues<-evalues[idx][1:plot_eigen]
evectors<-evectors[,idx[1:plot_eigen]]
#Create Plot
m<-ceiling((1+plot_eigen)/3)
par(mfrow=c(m,3))
plot(evalues[order(evalues)],main="Eigenvalues",ylab="eigenvalues")
for(i in 1:plot_eigen){
make_title<-paste(paste(i,"th",sep=""),"Eigenvector")
plot(evectors[,i],type="l",main=make_title,ylab="values")
}
km<-kmeans(evectors,centers=k)
cluster<-km$cluster
return(cluster)
}
}
iris[1,]
dat<-iris[,1:4]
spectrulClustering(dat,sigma=3,plot_eigen=20,k=3)
spectrulClustering(dat,sigma=3,plot_eigen=5,k=3)
spectrulClustering(dat,sigma=3,plot_eigen=1,k=3)
x<-dat
W<-similarity_mat(x,sigma=sigma)
D<-diag(apply(W,1,sum))
L<-D-W
L
eigenL<-eigen(L)
evalues<-eigenL$values
evectors<-eigenL$vectors
evectors
evectors[1:10,]
idx<-order(evalues)
evalues<-evalues[idx][1:plot_eigen]
evectors<-evectors[,idx[1:plot_eigen]]
evectors
plot_eigen
plot_eigen<-1
idx<-order(evalues)
evalues<-evalues[idx][1:plot_eigen]
evectors<-evectors[,idx[1:plot_eigen]]
evectors
spectrulClustering<-function(x,sigma,plot_eigen,k){
#x is data
#sigma is sigma used in Gaussian function
#num_plot is how many eigenvalues are plotted from the smallest?
#k is the kmeans clustering's parameter
n<-dim(x)[1]
if(plot_eigen>n){
stop("Number of eigenvalues for plot is larger than the number of data points")
}else{
#Get W, D and L
W<-similarity_mat(x,sigma=sigma)
D<-diag(apply(W,1,sum))
L<-D-W
#Calculate eigenvalues/vectors
eigenL<-eigen(L)
evalues<-eigenL$values
evectors<-eigenL$vectors
#Order eigenvalues from the smallest to the largest
idx<-order(evalues)
evalues<-evalues[idx][1:plot_eigen]
evectors<-evectors[,idx[1:plot_eigen]]
#Create Plot
m<-ceiling((1+plot_eigen)/3)
par(mfrow=c(m,3))
plot(evalues[order(evalues)],main="Eigenvalues",ylab="eigenvalues")
if(plot_eigen==1){
make_title<-paste(paste(i,"th",sep=""),"Eigenvector")
plot(evectors,type="l",main=make_title,ylab="values")
}else{
for(i in 1:plot_eigen){
make_title<-paste(paste(i,"th",sep=""),"Eigenvector")
plot(evectors[,i],type="l",main=make_title,ylab="values")
}
}
km<-kmeans(evectors,centers=k)
cluster<-km$cluster
return(cluster)
}
}
spectrulClustering(dat,sigma=3,plot_eigen=1,k=3)
spectrulClustering<-function(x,sigma,plot_eigen,k){
#x is data
#sigma is sigma used in Gaussian function
#num_plot is how many eigenvalues are plotted from the smallest?
#k is the kmeans clustering's parameter
n<-dim(x)[1]
if(plot_eigen>n){
stop("Number of eigenvalues for plot is larger than the number of data points")
}else{
#Get W, D and L
W<-similarity_mat(x,sigma=sigma)
D<-diag(apply(W,1,sum))
L<-D-W
#Calculate eigenvalues/vectors
eigenL<-eigen(L)
evalues<-eigenL$values
evectors<-eigenL$vectors
#Order eigenvalues from the smallest to the largest
idx<-order(evalues)
evalues<-evalues[idx][1:plot_eigen]
evectors<-evectors[,idx[1:plot_eigen]]
#Create Plot
m<-ceiling((1+plot_eigen)/2)
par(mfrow=c(m,2))
plot(evalues[order(evalues)],main="Eigenvalues",ylab="eigenvalues")
if(plot_eigen==1){
make_title<-paste(paste(i,"th",sep=""),"Eigenvector")
plot(evectors,type="l",main=make_title,ylab="values")
}else{
for(i in 1:plot_eigen){
make_title<-paste(paste(i,"th",sep=""),"Eigenvector")
plot(evectors[,i],type="l",main=make_title,ylab="values")
}
}
km<-kmeans(evectors,centers=k)
cluster<-km$cluster
return(cluster)
}
}
spectrulClustering(dat,sigma=3,plot_eigen=1,k=3)
spectrulClustering<-function(x,sigma,plot_eigen,k){
#x is data
#sigma is sigma used in Gaussian function
#num_plot is how many eigenvalues are plotted from the smallest?
#k is the kmeans clustering's parameter
n<-dim(x)[1]
if(plot_eigen>n){
stop("Number of eigenvalues for plot is larger than the number of data points")
}else{
#Get W, D and L
W<-similarity_mat(x,sigma=sigma)
D<-diag(apply(W,1,sum))
L<-D-W
#Calculate eigenvalues/vectors
eigenL<-eigen(L)
evalues<-eigenL$values
evectors<-eigenL$vectors
#Order eigenvalues from the smallest to the largest
idx<-order(evalues)
evalues<-evalues[idx][1:plot_eigen]
evectors<-evectors[,idx[1:plot_eigen]]
#K-means
km<-kmeans(evectors,centers=k)
cluster<-km$cluster
return(list(eigenvalues=evalues, eigenvectors= evectors, cluster=cluster))
}
}
spectrulClustering(dat,sigma=3,plot_eigen=1,k=3)
gaussian_dist<-function(x1,x2,sigma){
tmp<-sqrt(sum((x1-x2)^2))
y<-exp(-tmp/sigma^2)
return(y)
}
#similarity Matrix
similarity_mat<-function(x,sigma=1,num_eigen=3){
n<-dim(x)[1]
res<-matrix(0,n,n)
for(i in 1:n){
for(j in 1:n){
if(i>j){
res[i,j]<-gaussian_dist(x1=x[i,],x2=x[j,],sigma=sigma)
res[j,i]<-res[i,j]
}
}
}
max_sim<-max(apply(res,1,max))
res<-res/max_sim
return(res)
}
spectrulClustering<-function(x,sigma,plot_eigen,k){
#x is data
#sigma is sigma used in Gaussian function
#num_plot is how many eigenvalues are plotted from the smallest?
#k is the kmeans clustering's parameter
n<-dim(x)[1]
if(plot_eigen>n){
stop("Number of eigenvalues for plot is larger than the number of data points")
}else{
#Get W, D and L
W<-similarity_mat(x,sigma=sigma)
D<-diag(apply(W,1,sum))
L<-D-W
#Calculate eigenvalues/vectors
eigenL<-eigen(L)
evalues<-eigenL$values
evectors<-eigenL$vectors
#Order eigenvalues from the smallest to the largest
idx<-order(evalues)
evalues<-evalues[idx][1:plot_eigen]
evectors<-evectors[,idx[1:plot_eigen]]
#K-means
km<-kmeans(evectors,centers=k)
cluster<-km$cluster
return(list(eigenvalues=evalues, eigenvectors= evectors, cluster=cluster))
}
}
?dist
dist(x,"euclidean", diag = TRUE, upper = TRUR)
x<-matrix(c(1,2,
1,4,
5,6,
8,9,
2,2),ncol=2)
x
dist(x)
dist(x,"euclidean", diag = TRUE, upper = TRUR)
dist(x,"euclidean", diag = TRUE, upper = TRUE)
d<-dist(x,"euclidean", diag = TRUE, upper = TRUE)
d
d[,1]
d[1,1]
d
class(d)
d<-as.matrix(d)
d
d[1]
d[1,1]
d[1,]
d<-dist(x,"euclidean", diag = FALSE, upper = TRUE)
d<-as.matrix(d)
d
d[,1]
order(d[,1])
order(d[,1]) !=1
idx<-order(d[,1])
idx<-idx[idx!=1]
ix
idx
idx<-order(d[,1])
idx<-idx[idx!=1][1:k]
k<-2
idx<-idx[idx!=1][1:k]
idx
n<-dim(x)[1]
res<-matrix(0,n,n)
res[i,idx]
i<-1
res[i,idx]
res[i,idx]<-1
res
res[idx,i]<-1
res
knn_mat<-function(x,k){
n<-dim(x)[1]
res<-matrix(0,n,n)
d<-dist(x,"euclidean", diag = FALSE, upper = TRUE)
d<-as.matrix(d)
for(i in 1:n){
idx<-order(d[,i])
idx<-idx[idx!=i][1:k]
res[i,idx]<-1
res[idx,i]<-1
}
return(res)
}
knn_mat(x,k=2)
x<-matrix(c(1,2,
1,4,
5,6,
8,9,
2,2),ncol=2)
x
source("Documents/MSAN/MVA/spectrul_clustering.R")
spectrulClustering(x,similarity="Knn",k=3,plot_eigen=3,centers=2)
source("Documents/MSAN/MVA/spectrul_clustering.R")
spectrulClustering(x,similarity="Knn",k=3,plot_eigen=3,centers=2)
x<-matrix(c(1,2,
1,4,
10,10,
10,9,
11,12),ncol=2)
spectrulClustering(x,similarity="Knn",k=3,plot_eigen=3,centers=2)
x<-matrix(c(1,2,1
1,4,1
10,10,10
10,9,10
11,12,10),ncol=2)
x<-matrix(c(1,2,1,
1,4,1,
10,10,10
10,9,10
11,12,10),ncol=3)
x<-matrix(c(1,2,1,
1,4,1,
10,10,10,
10,9,10,
11,12,10),ncol=3, byrow=T)
x
spectrulClustering(x,similarity="Knn",k=3,plot_eigen=3,centers=2)
x<-iris[,1:4]
x[1,]
plot(x[,1:2])
spectrulClustering(x,similarity="Knn",k=3,plot_eigen=3,centers=2)
spectrulClustering(x,similarity="Knn",k=3,plot_eigen=3,centers=3)
sim_timeline = 20
precision = 0.69
target_customer = 10000
camp_cost = 10
payout_int_rate = 0.01
ave_balance = 10000
balance_rate = 0.2
inv_int_rate = 0.05
ret_cost = 10
churn = 0.01
discount_rate = 0.1
timeline<- paste("YR",1:sim_timeline,sep="")
after_timeline<-paste("After_YR",sim_timeline+1,sep="")
timeline<-c(timeline,after_timeline)
customer<-rep(0,length(timeline))
customer[1]<-precision*target_customer
op_cost<-rep(0,length(timeline))
op_cost[1]<-customer[1]*ret_cost
principal<-rep(0,length(timeline))
principal[1]<-customer[1]*ave_balance*balance_rate
gain<-rep(0,length(timeline))
gain[1]<-principal[1]*inv_int_rate
payout<-rep(0,length(timeline))
payout[1]<-principal[1]*payout_int_rate
total_cost<-rep(0,length(timeline))
total_cost[1]<-op_cost[1]+payout[1]
profit_raw<-rep(0,length(timeline))
profit_raw[1]<-gain[1]-total_cost[1]
profit_disc<-rep(0,length(timeline))
profit_disc[1]<-profit_raw[1]/(1+discount_rate)
for(i in 2:(length(timeline))){
if(i==length(timeline)){
profit_disc[i]<-profit_raw[i-1]/discount_rate
customer[i]<-customer[i-1]
op_cost[i]<-op_cost[i-1]
principal[i]<-principal[i-1]
gain[i]<-gain[i-1]
payout[i]<-payout[i-1]
total_cost[i]<-total_cost[i-1]
profit_raw[i]<-profit_raw[i-1]
}else{
customer[i]<-customer[i-1]*(1-churn)
op_cost[i]<-customer[i]*ret_cost
principal[i]<-principal[i-1]+gain[i-1]
gain[i]<-principal[i]*inv_int_rate
payout[i]<-principal[i]*payout_int_rate
total_cost[i]<-op_cost[i]+payout[i]
profit_raw[i]<-gain[i]-total_cost[i]
profit_disc[i]<-profit_raw[i]/(1+discount_rate)^i
}
}
sim_table<-as.data.frame(t(cbind(customer,principal,gain,payout,op_cost,total_cost,profit_raw,profit_disc)))
colnames(sim_table)<-timeline
row.names(sim_table)<-c("# of Customer","Principal","Revenue","Interest Expense","Retention Cost","Total Cost","Cash Flow","Discounted Cash Flow")
Year<-colnames(sim_table)
Year<-Year[-length(Year)]
sim_table<-as.data.frame(t(sim_table))
sim_table$Year<-1:dim(sim_table)[1]
df1<-sim_table[-dim(sim_table)[1],]
gain_cost<-melt(df1,id.vars="Year",measure.vars=c("Revenue","Total Cost"))
library(ggplot2)
library(reshape2)
library(reshape)
library(scales)
library(grid)
library(plyr)
library(RColorBrewer)
gain_cost<-melt(df1,id.vars="Year",measure.vars=c("Revenue","Total Cost"))
profit<-melt(df1,id.vars="Year",measure.vars="Cash Flow")
profit
profit$positive<-ifelse(profit$value>0,"positive","negative")
profit$positive<-relevel(profit$positive,ref="positive")
profit$positive<-ifelse(profit$value>0,"positive","negative")
profit$positive<-relevel(profit$positive,ref="positive")
profit$positive<-as.factor(ifelse(profit$value>0,"positive","negative"))
profit$positive<-relevel(profit$positive,ref="positive")
profit
colourList<-setNames(c("blue", "red"),levels(profit$positive))
p2<-ggplot(profit)+geom_bar(aes(x=as.factor(Year), y=value),fill=positive,size=3,stat="identity")
profit
profit[,4]
p2<-ggplot(profit)+geom_bar(aes(x=as.factor(Year), y=value,fill=positive),size=3,stat="identity")
p2
p2<-ggplot(profit)+geom_bar(aes(x=as.factor(Year), y=value,fill=positive),size=3,stat="identity")
p2<-p2+scale_x_discrete(labels=Year)+scale_y_continuous(label = thousand_formatter)
p2<-p2+scale_fill_manual(values=colourList)
thousand_formatter <- function(x) {
return(round(x / 1000))
}
p2<-ggplot(profit)+geom_bar(aes(x=as.factor(Year), y=value,fill=positive),size=3,stat="identity")
p2<-p2+scale_x_discrete(labels=Year)+scale_y_continuous(label = thousand_formatter)
p2<-p2+scale_fill_manual(values=colourList)
p2<-p2+labs(title="Profit/Loss", x="YEAR",y="Profit in Euro (K)")
p2<-p2+theme(panel.background = element_rect(fill="white",colour="black"),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
panel.grid.major.y = element_line(color="gray",size=0.5),
panel.grid.minor.y = element_blank(),
plot.title = element_text(size=20),
axis.title.x = element_text(size=16,colour="black"),
axis.title.y = element_text(size=16,colour="black"),
axis.text.y=element_text(size=14,colour="black"),
axis.text.x=element_text(size=14,colour="black"),
legend.position = "none",
legend.title = element_text(size=16),
legend.text = element_text(size=14),
legend.key = element_rect(fill = "White"))+guides(colour = guide_legend(override.aes = list(size = 2)))
p2
setwd("Documents/MSAN/Data_Visalization/msan622/final-project/")
runApp()
librarr(shiny)
library(shiny)
runApp()
runApp()
profit$positive<-factor(profit$positive, levels = c("positive", "negative"), lavels=profit$positive)
profit$positive<-factor(profit$positive, levels = c("positive", "negative"), labels=profit$positive)
profit$positive<-factor(profit$positive, levels = c("positive", "negative"))
profit
profit[,4]
runApp()
runApp()
runApp()
data<-read.csv("bank-full.csv",sep=";")
data$job<-as.character(data$job)
data$job[data$job=="blue-collar"]<-"blue_collar"
data$job<-factor(data$job)
colnames(data)[17]<-"subscribed"
data$subscribed<-relevel(data$subscribed,ref="yes")
data$subscribed<-relevel(data$subscribed,ref="no")
idx<-sample(1:dim(data)[1],dim(data)[1]*train_size)
train_size=0.9
idx<-sample(1:dim(data)[1],dim(data)[1]*train_size)
y_var<-"subscribed"
x_idx<-which(colnames(data) %in% x_var)
y_idx<-which(colnames(data) == y_var)
x_var=c("age","job","balance")
y_var="subscribed"
y_var<-"subscribed"
x_idx<-which(colnames(data) %in% x_var)
y_idx<-which(colnames(data) == y_var)
x<-data[,x_idx]
y<-data[,y_idx]
df<-cbind(y,x)
colnames(df)[1]<-"subscribed"
data_glm<-glm(subscribed~.,data=df[idx,],family="binomial")
data_glm_summary<-summary(data_glm)
coef<-data_glm_summary$coef
data_mm<-model.matrix(data_glm)
df_scale<-as.data.frame(cbind(y[idx],as.data.frame(scale(data_mm[,-1]))))
colnames(df_scale)[1]<-"subscribed"
data_glm_scale<-glm(subscribed~.,data=df_scale,family="binomial")
data_glm_scale_summary<-summary(data_glm_scale)
coef_scale<-data_glm_scale_summary$coef[-1,]
significance_scale<-ifelse(coef_scale[,4]<0.001,"p-value < 0.1%",
ifelse((coef_scale[,4] < 0.01) & (coef_scale[,4]>=0.001), "p-value < 1%",
ifelse((coef_scale[,4] < 0.05) & (coef_scale[,4]>=0.01),"p-value < 5%", "p-value >=5%")))
imp_scale<-data.frame(Importance = coef_scale[,1])
importanceData_scale<-data.frame(variable_name = factor(row.names(imp_scale),levels=row.names(imp_scale)),
Importance = as.numeric(imp_scale[,1]),
significance = factor(as.character(significance_scale), level = c("p-value < 0.1%","p-value < 1%","p-value < 5%","p-value >=5%")))
importanceData_scale
coef_scale
coef_scale[,4]
imp_scale<-data.frame(Importance = coef_scale[,1],p_value=coef_scale[,4])
importanceData_scale<-data.frame(variable_name = factor(row.names(imp_scale),levels=row.names(imp_scale)),
Importance = as.numeric(imp_scale[,1]),
p_value = imp_scale[,2],
significance = factor(as.character(significance_scale), level = c("p-value < 0.1%","p-value < 1%","p-value < 5%","p-value >=5%")))
importanceData_scale
runApp(())
runApp(
)
runApp()
